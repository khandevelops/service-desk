{"version":3,"file":"FocusZone.types.js","names":[],"sources":["FocusZone/FocusZone.types.ts"],"sourcesContent":["import { FocusZoneDirection, FocusZoneProperties, FocusZoneTabbableElements } from '@fluentui/accessibility';\nimport * as React from 'react';\n\n/**\n * FocusZone component class interface.\n */\nexport interface IFocusZone {\n  /**\n   * Sets focus to the first tabbable item in the zone.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element, even if focus is already in the focus zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focus(forceIntoFirstElement?: boolean): boolean;\n\n  /**\n   * Sets focus to the last tabbable item in the zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focusLast(): boolean;\n\n  /**\n   * Sets focus to a specific child element within the zone. This can be used in conjunction with\n   * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct\n   * location and then focus.)\n   * @param element - The child element within the zone to focus.\n   * @param forceAlignment - If true, focus alignment will be set according to the element provided.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focusElement(childElement?: HTMLElement, forceAlignment?: boolean): boolean;\n}\n\n// Heads up! Keep in sync with packages/accessibility/src/focusZone/types.ts\n/**\n * FocusZone component props.\n */\nexport interface FocusZoneProps extends FocusZoneProperties, React.HTMLAttributes<HTMLElement> {\n  /** @docSiteIgnore */\n  as?: React.ReactType;\n  /**\n   * Additional class name to provide on the root element, in addition to the ms-FocusZone class.\n   */\n  className?: string;\n\n  /**\n   * Defines which arrows to react to.\n   * It has next options: horizontal, vertical, bidirectional, bidirectionalDomOrder.\n   * @default FocusZoneDirection.bidirectional\n   */\n  direction?: FocusZoneDirection;\n\n  /**\n   * Optionally defines the initial tabbable element inside the FocusZone.\n   * If a string is passed then it is treated as a selector for identifying the initial tabbable element.\n   * If a function is passed then it uses the root element as a parameter to return the initial tabbable element.\n   * For example, when there is a chat with a bottom-up approach, it is expected that the last chat message is tabbable (active), not the first default one.\n   */\n  defaultTabbableElement?: string | ((root: HTMLElement) => HTMLElement);\n\n  /**\n   * Determines if a default tabbable element should be force focused on FocusZone mount.\n   * @default false\n   */\n  shouldFocusOnMount?: boolean;\n\n  /**\n   * If true and FocusZone's root element (container) receives focus, the focus will land either on the\n   * defaultTabbableElement (if set) or on the first tabbable element of this FocusZone.\n   * Usually a case for nested focus zones, when the nested focus zone's container is a focusable element.\n   */\n  shouldFocusInnerElementWhenReceivedFocus?: boolean;\n\n  /**\n   * If true and TAB key is not handled by FocusZone, resets current active element to null value.\n   * For example, when roving index is not desirable and focus should always reset to the default tabbable element.\n   */\n  shouldResetActiveElementWhenTabFromZone?: boolean;\n\n  /**\n   * If true elements containing data-is-focusable=\"false\" will not be counted skipping onFocus event\n   */\n  shouldIgnoreNotFocusable?: boolean;\n\n  /**\n   * Determines whether the FocusZone will walk up the DOM trying to invoke click callbacks on focusable elements on\n   * Enter and Space keydowns to ensure accessibility for tags that don't guarantee this behavior.\n   */\n  shouldRaiseClicks?: boolean;\n\n  /**\n   * If set, the FocusZone will not be tabbable and keyboard navigation will be disabled.\n   * This does not affect disabled attribute of any child.\n   */\n  disabled?: boolean;\n\n  /**\n   * If true, FocusZone behavior will change to match RTL environments (left/right arrows switched).\n   */\n  isRtl?: boolean;\n\n  /**\n   * If true, will cycle to the beginning of the targets once the user attempts to navigate past the last\n   * target while at the end, and to the end when the user attempts to naviagate before the first target.\n   */\n  isCircularNavigation?: boolean;\n\n  /**\n   * Callback function that will be executed on keypresses to determine if the user intends to navigate into\n   * the inner (nested) zone. Returning true will ask the first inner zone to set focus.\n   * For example, when chat container is FocusZone and chat messages are inner focus zones.\n   * Navigation between messages possible with up/down arrow keys, but when pressing Enter, focus should go to\n   * focusable elements inside message, for example, a link.\n   */\n  shouldEnterInnerZone?: (ev: React.KeyboardEvent<HTMLElement>) => boolean;\n\n  /**\n   * Callback for when one of immediate children elements gets active by getting focused\n   * or by having one of its respective children elements focused.\n   */\n  onActiveElementChanged?: (element?: HTMLElement, ev?: React.FocusEvent<HTMLElement>) => void;\n\n  /**\n   * Callback method for determining if focus should indeed be set on the given element.\n   * @param element - The child element within the zone to focus.\n   * @returns True if focus should be set to the given element, false to avoid setting focus.\n   */\n  shouldReceiveFocus?: (childElement?: HTMLElement) => boolean;\n\n  /** Allows focus to park on root when focus is in the `FocusZone` at render time. */\n  allowFocusRoot?: boolean;\n\n  /**\n   * Allows TAB key to be handled, thus alows tabbing through a focusable list of items in the\n   * focus zone. A side effect is that users will not be able to TAB out of the focus zone and\n   * have to hit escape or some other key to exit focus zone.\n   * Enum options:\n   * none - tabbing is not allowed\n   * all - all tabbing action is allowed\n   * inputOnly - tabbing is allowed only on input elements\n   */\n  handleTabKey?: FocusZoneTabbableElements;\n\n  /**\n   * A callback method to determine if the input element should lose focus on arrow keys.\n   * For example: use arrow keys to navigate when an input element is empty or when cursor is at the beginning/end of a string.\n   * @param inputElement - The input element which is to lose focus.\n   * @returns True if input element should lose focus or false otherwise.\n   */\n  shouldInputLoseFocusOnArrowKey?: (inputElement: HTMLInputElement) => boolean;\n\n  /**\n   * Determines whether to disable the paging support for Page Up and Page Down keyboard scenarios.\n   * @defaultvalue false\n   */\n  pagingSupportDisabled?: boolean;\n\n  /**\n   * Determines whether to check for data-no-horizontal-wrap or data-no-vertical-wrap attributes\n   * when determining how to move focus\n   * @defaultvalue false\n   */\n  checkForNoWrap?: boolean;\n\n  /**\n   * Whether the FocusZone should allow focus events to propagate past the FocusZone.\n   */\n  stopFocusPropagation?: boolean;\n\n  /**\n   * Callback called when \"focus\" event triggered in FocusZone.\n   * @param event - React's original FocusEvent.\n   */\n  onFocus?: (event: React.FocusEvent<HTMLElement>) => void;\n\n  /**\n   * If true, FocusZone prevents the default behavior of Keyboard events when changing focus between elements.\n   */\n  preventDefaultWhenHandled?: boolean;\n\n  /**\n   * If true, prevents the FocusZone from attempting to restore the focus to the inner element when the focus is on the\n   * root element after componentDidUpdate.\n   * @defaultvalue false\n   */\n  preventFocusRestoration?: boolean;\n\n  innerRef?: React.Ref<any>;\n}\n"],"mappings":""}