{"version":3,"file":"focusUtilities.js","names":["IS_FOCUSABLE_ATTRIBUTE","getWindow","getParent","IS_VISIBLE_ATTRIBUTE","FOCUSZONE_ID_ATTRIBUTE","FOCUSZONE_SUB_ATTRIBUTE","HIDDEN_FROM_ACC_TREE","getDocument","getFirstFocusable","rootElement","currentElement","includeElementsInFocusZones","getNextElement","getLastFocusable","getPreviousElement","getFirstTabbable","checkNode","getLastTabbable","suppressParentTraversal","traverseChildren","tabbable","isCurrentElementVisible","isElementVisible","isElementFocusZone","isElementFocusSubZone","childMatch","lastElementChild","isElementTabbable","childMatchSiblingMatch","previousElementSibling","childMatchParent","parentElement","childMatchParentMatch","siblingMatch","suppressChildTraversal","firstElementChild","nextElementSibling","element","getAttribute","visibilityAttribute","undefined","offsetHeight","offsetParent","isVisible","checkTabIndex","disabled","tabIndex","tabIndexAttributeValue","parseInt","isFocusableAttribute","isTabIndexSet","result","tagName","targetToFocusOnNextRepaint","focusAsync","options","win","requestAnimationFrame","focus","getFocusableByIndexPath","parent","path","_iterator","_createForOfIteratorHelperLoose","_step","done","index","value","nextChild","children","Math","min","length","getElementIndexPath","fromElement","toElement","unshift","Array","prototype","indexOf","call"],"sources":["FocusZone/focusUtilities.ts"],"sourcesContent":["import { IS_FOCUSABLE_ATTRIBUTE } from '@fluentui/accessibility';\nimport { getWindow } from '../utils/getWindow';\nimport { getParent } from '@fluentui/dom-utilities';\n\nexport const IS_VISIBLE_ATTRIBUTE = 'data-is-visible';\nexport const FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nexport const FOCUSZONE_SUB_ATTRIBUTE = 'data-is-sub-focuszone';\nexport const HIDDEN_FROM_ACC_TREE = 'data-is-hidden-from-acc-tree';\n\nexport { getDocument } from '../utils/getDocument';\nexport { getWindow } from '../utils/getWindow';\nexport { getParent } from '@fluentui/dom-utilities';\n\n/**\n * Gets the first focusable element.\n *\n * @public\n */\nexport function getFirstFocusable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n): HTMLElement | null {\n  return getNextElement(\n    rootElement,\n    currentElement,\n    true /* checkNode */,\n    false /* suppressParentTraversal */,\n    false /* suppressChildTraversal */,\n    includeElementsInFocusZones,\n  );\n}\n\n/**\n * Gets the last focusable element.\n *\n * @public\n */\nexport function getLastFocusable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n): HTMLElement | null {\n  return getPreviousElement(\n    rootElement,\n    currentElement,\n    true /* checkNode */,\n    false /* suppressParentTraversal */,\n    true /* traverseChildren */,\n    includeElementsInFocusZones,\n  );\n}\n\n/**\n * Gets the first tabbable element.\n * The difference between focusable and tabbable is that tabbable elements are focusable elements that also have tabIndex != -1.\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues forward.  Typical use passes rootElement.firstChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @public\n */\nexport function getFirstTabbable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n  checkNode?: boolean,\n): HTMLElement | null {\n  return getNextElement(\n    rootElement,\n    currentElement,\n    checkNode,\n    false /* suppressParentTraversal */,\n    false /* suppressChildTraversal */,\n    includeElementsInFocusZones,\n    true /* tabbable */,\n  );\n}\n\n/**\n * Gets the last tabbable element.\n * The difference between focusable and tabbable is that tabbable elements are focusable elements that also have tabIndex != -1.\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues in reverse.  Typical use passes rootElement.lastChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @public\n */\nexport function getLastTabbable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n  checkNode?: boolean,\n): HTMLElement | null {\n  return getPreviousElement(\n    rootElement,\n    currentElement,\n    checkNode,\n    false /* suppressParentTraversal */,\n    true /* traverseChildren */,\n    includeElementsInFocusZones,\n    true /* tabbable */,\n  );\n}\n\n/**\n * Traverse to find the previous element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n */\nexport function getPreviousElement(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement | null,\n  checkNode?: boolean,\n  suppressParentTraversal?: boolean,\n  traverseChildren?: boolean,\n  includeElementsInFocusZones?: boolean,\n  tabbable?: boolean,\n): HTMLElement | null {\n  if (!currentElement || currentElement === rootElement) {\n    return null;\n  }\n\n  const isCurrentElementVisible = isElementVisible(currentElement);\n\n  // Check its children.\n  if (\n    traverseChildren &&\n    isCurrentElementVisible &&\n    (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))\n  ) {\n    const childMatch = getPreviousElement(\n      rootElement,\n      currentElement.lastElementChild as HTMLElement,\n      true,\n      true,\n      true,\n      includeElementsInFocusZones,\n      tabbable,\n    );\n\n    if (childMatch) {\n      if ((tabbable && isElementTabbable(childMatch, true)) || !tabbable) {\n        return childMatch;\n      }\n\n      const childMatchSiblingMatch = getPreviousElement(\n        rootElement,\n        childMatch.previousElementSibling as HTMLElement,\n        true,\n        true,\n        true,\n        includeElementsInFocusZones,\n        tabbable,\n      );\n      if (childMatchSiblingMatch) {\n        return childMatchSiblingMatch;\n      }\n\n      let childMatchParent = childMatch.parentElement;\n\n      // At this point if we have not found any potential matches\n      // start looking at the rest of the subtree under the currentParent.\n      // NOTE: We do not want to recurse here because doing so could\n      // cause elements to get skipped.\n      while (childMatchParent && childMatchParent !== currentElement) {\n        const childMatchParentMatch = getPreviousElement(\n          rootElement,\n          childMatchParent.previousElementSibling as HTMLElement,\n          true,\n          true,\n          true,\n          includeElementsInFocusZones,\n          tabbable,\n        );\n\n        if (childMatchParentMatch) {\n          return childMatchParentMatch;\n        }\n\n        childMatchParent = childMatchParent.parentElement;\n      }\n    }\n  }\n\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {\n    return currentElement;\n  }\n\n  // Check its previous sibling.\n  const siblingMatch = getPreviousElement(\n    rootElement,\n    currentElement.previousElementSibling as HTMLElement,\n    true,\n    true,\n    true,\n    includeElementsInFocusZones,\n    tabbable,\n  );\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  // Check its parent.\n  if (!suppressParentTraversal) {\n    return getPreviousElement(\n      rootElement,\n      currentElement.parentElement,\n      true,\n      false,\n      false,\n      includeElementsInFocusZones,\n      tabbable,\n    );\n  }\n\n  return null;\n}\n\n/**\n * Traverse to find the next focusable element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n */\nexport function getNextElement(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement | null,\n  checkNode?: boolean,\n  suppressParentTraversal?: boolean,\n  suppressChildTraversal?: boolean,\n  includeElementsInFocusZones?: boolean,\n  tabbable?: boolean,\n): HTMLElement | null {\n  if (!currentElement || (currentElement === rootElement && suppressChildTraversal)) {\n    return null;\n  }\n\n  const isCurrentElementVisible = isElementVisible(currentElement);\n\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {\n    return currentElement;\n  }\n\n  // Check its children.\n  if (\n    !suppressChildTraversal &&\n    isCurrentElementVisible &&\n    (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))\n  ) {\n    const childMatch = getNextElement(\n      rootElement,\n      currentElement.firstElementChild as HTMLElement,\n      true,\n      true,\n      false,\n      includeElementsInFocusZones,\n      tabbable,\n    );\n\n    if (childMatch) {\n      return childMatch;\n    }\n  }\n\n  if (currentElement === rootElement) {\n    return null;\n  }\n\n  // Check its sibling.\n  const siblingMatch = getNextElement(\n    rootElement,\n    currentElement.nextElementSibling as HTMLElement,\n    true,\n    true,\n    false,\n    includeElementsInFocusZones,\n    tabbable,\n  );\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  if (!suppressParentTraversal) {\n    return getNextElement(\n      rootElement,\n      currentElement.parentElement,\n      false,\n      false,\n      true,\n      includeElementsInFocusZones,\n      tabbable,\n    );\n  }\n\n  return null;\n}\n\n/**\n * Determines if an element is visible.\n *\n * @public\n */\nexport function isElementVisible(element: HTMLElement | undefined | null): boolean {\n  // If the element is not valid, return false.\n  if (!element || !element.getAttribute) {\n    return false;\n  }\n\n  const visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);\n\n  // If the element is explicitly marked with the visibility attribute, return that value as boolean.\n  if (visibilityAttribute !== null && visibilityAttribute !== undefined) {\n    return visibilityAttribute === 'true';\n  }\n\n  // Fallback to other methods of determining actual visibility.\n  return (\n    element.offsetHeight !== 0 ||\n    element.offsetParent !== null ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (element as any).isVisible === true\n  ); // used as a workaround for testing.\n}\n\n/**\n * Determines if an element can receive focus programmatically or via a mouse click.\n * If checkTabIndex is true, additionally checks to ensure the element can be focused with the tab key, meaning tabIndex != -1.\n *\n * @public\n */\nexport function isElementTabbable(element: HTMLElement, checkTabIndex?: boolean): boolean {\n  // If this element is null or is disabled, it is not considered tabbable.\n  if (!element || (element as HTMLButtonElement).disabled) {\n    return false;\n  }\n\n  let tabIndex = 0;\n  let tabIndexAttributeValue: string | null = null;\n\n  if (element && element.getAttribute) {\n    tabIndexAttributeValue = element.getAttribute('tabIndex');\n\n    if (tabIndexAttributeValue) {\n      tabIndex = parseInt(tabIndexAttributeValue, 10);\n    }\n  }\n\n  const isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;\n  const isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;\n\n  const result =\n    !!element &&\n    isFocusableAttribute !== 'false' &&\n    (element.tagName === 'A' ||\n      element.tagName === 'BUTTON' ||\n      element.tagName === 'INPUT' ||\n      element.tagName === 'TEXTAREA' ||\n      isFocusableAttribute === 'true' ||\n      isTabIndexSet ||\n      (element.getAttribute && element.getAttribute('role') === 'button'));\n\n  return checkTabIndex ? tabIndex !== -1 && result : result;\n}\n\n/**\n * Determines if a given element is a focus zone.\n *\n * @public\n */\nexport function isElementFocusZone(element?: HTMLElement): boolean {\n  return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE));\n}\n\n/**\n * Determines if a given element is a focus sub zone.\n *\n * @public\n */\nexport function isElementFocusSubZone(element?: HTMLElement): boolean {\n  return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === 'true');\n}\n\nlet targetToFocusOnNextRepaint: HTMLElement | { focus: () => void } | null | undefined = undefined;\n\n/**\n * Sets focus to an element asynchronously. The focus will be set at the next browser repaint,\n * meaning it won't cause any extra recalculations. If more than one focusAsync is called during one frame,\n * only the latest called focusAsync element will actually be focused\n * @param element - The element to focus\n */\nexport function focusAsync(\n  element: HTMLElement | { focus: (options?: FocusOptions) => void } | undefined | null,\n  options?: FocusOptions,\n): void {\n  if (element) {\n    // An element was already queued to be focused, so replace that one with the new element\n    if (targetToFocusOnNextRepaint) {\n      targetToFocusOnNextRepaint = element;\n      return;\n    }\n\n    targetToFocusOnNextRepaint = element;\n\n    const win = getWindow(element as Element);\n\n    if (win) {\n      // element.focus() is a no-op if the element is no longer in the DOM, meaning this is always safe\n      win.requestAnimationFrame(() => {\n        targetToFocusOnNextRepaint && targetToFocusOnNextRepaint.focus(options);\n\n        // We are done focusing for this frame, so reset the queued focus element\n        targetToFocusOnNextRepaint = undefined;\n      });\n    }\n  }\n}\n\n/**\n * Finds the closest focusable element via an index path from a parent. See\n * `getElementIndexPath` for getting an index path from an element to a child.\n */\nexport function getFocusableByIndexPath(parent: HTMLElement, path: number[]): HTMLElement | undefined {\n  let element = parent;\n\n  for (const index of path) {\n    const nextChild = element.children[Math.min(index, element.children.length - 1)] as HTMLElement;\n\n    if (!nextChild) {\n      break;\n    }\n    element = nextChild;\n  }\n\n  element =\n    isElementTabbable(element) && isElementVisible(element)\n      ? element\n      : getNextElement(parent, element, true) || getPreviousElement(parent, element)!;\n\n  return element as HTMLElement;\n}\n\n/**\n * Finds the element index path from a parent element to a child element.\n *\n * If you had this node structure: \"A has children [B, C] and C has child D\",\n * the index path from A to D would be [1, 0], or `parent.chidren[1].children[0]`.\n */\nexport function getElementIndexPath(fromElement: HTMLElement, toElement: HTMLElement): number[] {\n  const path: number[] = [];\n  let currentElement: HTMLElement = toElement;\n\n  while (currentElement && fromElement && currentElement !== fromElement) {\n    const parent = getParent(currentElement, false);\n\n    if (parent === null) {\n      return [];\n    }\n\n    path.unshift(Array.prototype.indexOf.call(parent.children, currentElement));\n    currentElement = parent;\n  }\n\n  return path;\n}\n"],"mappings":"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"}